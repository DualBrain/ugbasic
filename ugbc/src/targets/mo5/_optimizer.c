/*****************************************************************************
 * ugBASIC - an isomorphic BASIC language compiler for retrocomputers        *
 *****************************************************************************
 * Copyright 2021 Marco Spedaletti (asimov@mclink.it)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *----------------------------------------------------------------------------
 * Concesso in licenza secondo i termini della Licenza Apache, versione 2.0
 * (la "Licenza"); è proibito usare questo file se non in conformità alla
 * Licenza. Una copia della Licenza è disponibile all'indirizzo:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Se non richiesto dalla legislazione vigente o concordato per iscritto,
 * il software distribuito nei termini della Licenza è distribuito
 * "COSÌ COM'È", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO, esplicite o
 * implicite. Consultare la Licenza per il testo specifico che regola le
 * autorizzazioni e le limitazioni previste dalla medesima.
 ****************************************************************************/

 /* 6809 optimizations for ugBasic by S.Devulder
  *
  * The idea here is to look for specific pattern over consecutive (1 to 4)
  * lines of code generated by ugBasic compiler, and reorganized it locally
  * by another pattern that contains a more efficent code for the cpu.
  *
  * It does multiples passes over the source as local rewrites can be
  * applied on previous rewrites, resulting in a avalanche effects that
  * optimizes the source far away from one can guess from the basic patterns.
  *
  * The optimizer can also do some data flow analysis. It can for isntance
  * see that one of the accumulator is $00 to simplify code. It can also
  * detect that some data in memory are written but never read. These are
  * called dead-data. It will then remove all reference to these data in
  * the code making it smaller and faster (as a useless write is not
  * performed anymore).
  *
  * Real full data-flow analysis should normally be able to detect data which
  * is written two times in a row whithout being read in between. These are
  * also called dead-data as the firs written value is lost. These typically
  * appear along previous optimisations passes. Write operation to these
  * dead-data can also be removed.
  *
  * Unfortunately this version of the optimized doesn't have yet a complete
  * data-flow analyzer, and heuristics is used to guess whether a memory
  * operation accesses a dead data. In that case the optimizer will indicate
  * in the commented-out code that the data is *presumed dead*. The
  * heuristics are carefully choosen from the patterns generated by ugBasic
  * and make good guesses. But if you consider these as too dangerous you
  * can disable all of them with the "ALLOW_UNSAFE" flag below.
  *
  * Last the optimizer will also attempt to reorganize the data to get a
  * faster & shorter code. Some data will be "inlined" in the code, making
  * the code auto-modifiable which is no problem for the mc6809. And some
  * "heavily used" data will be moved into the direct-page location for
  * faster accesses.
  */

/****************************************************************************
 * INCLUDE SECTION
 ****************************************************************************/

#include "../../ugbc.h"
#include <stdarg.h>

/****************************************************************************
 * CODE SECTION
 ****************************************************************************/

#define DIRECT_PAGE     0x2100
#define LOOK_AHEAD      4
#define ALLOW_UNSAFE    1
#define KEEP_COMMENTS   1

/* returns true if the buffer matches a comment or and empty line */
int isAComment( char * _buffer ) {
    if ( ! *_buffer ) {
        return 1;
    }
    if ( *_buffer == 0x0d || *_buffer == 0x0a ) {
        return 1;
    }
    while( * _buffer ) {
        if ( *_buffer == ' ' || *_buffer == '\t' ) {
            ++_buffer;
        } else if ( *_buffer == ';' ) {
            return 1;
        } else {
            return 0;
        }
    }
    return 0;
}

/* returns an UPPER-cased char */
static inline char _toUpper(char a) {
    return (a>='a' && a<='z') ? a-'a'+'A' : a;
}

/* returns true if char is end of line ? */
static inline int _eol(char c) {
    return c=='\0' || c=='\n';
}

/* returns true if both char matches */
static inline int _eq(char pat, char txt) {
    return (pat<=' ') ? (txt<=' ') : (_toUpper(pat)==_toUpper(txt));
}

/* a version of strcmp that ends at EOL and deal with NULL */
int _strcmp(char *s, char *t) {
    if(s==NULL || t==NULL) return 1;
    while(!_eol(*s) && !_eol(*t) && _eq(*s,*t)) {
        ++s;
        ++t;
    }
    return _eol(*s) && _eol(*t) ? 0 : 1;
}

/* Matches a string:
    - ' ' maches anthing <= ' ' (eg 'r', \n', '\t' or ' ' )
    - '*' matches at least one char up to the next one in the pattern. 
          Matched content is copied into buffers passed as varargs. If 
          a buffer is NULL the matched content is not copied.

   returns NULL if string and pattern mismatch or the last matched '*' or _s.
*/
static char *match(char *_string, char *_pattern, ...) {
    char *s = _string, *p = _pattern;
    char *ret = s;
    va_list ap;

    va_start(ap, _pattern);
    
    while(!_eol(*s) && *p) {
        if(*p==' ') {while(*p==' ') ++p;
            if(!_eq(' ', *s)) {
                ret = NULL;
                break;
            }
            while(!_eol(*s) && _eq(' ', *s)) ++s;
        } else if(*p=='*') {
            char *m = va_arg(ap, char*); ++p;
            if(*p && _eq(*p, *s)) { /* matches at lease one char */
                ret = NULL;
                break;
            }
            ret = m == NULL ? s : m;
            do {
                if(m) *m++ = *s;
                ++s;
            } while(!_eol(*s) && !_eq(*p, *s));
            if(m) *m='\0';
        } else if(_toUpper(*s++) != _toUpper(*p++)) {
            ret = NULL;
            break;
        }
    }
    
    va_end(ap);

    return *p=='\0' ? ret : NULL;
}

/* returns true if buf matches any op using the ALU between memory and a register */
static int alu_op(char *buf, char *REG) {
    if(match(buf, " ADD* ", REG)) return 1;
    if(match(buf, " AND* ", REG)) return 1;
    if(match(buf, " CMP* ", REG)) return 1;
    if(match(buf, " EOR* ", REG)) return 1;
    if(match(buf, " LD* ",  REG)) return 1;
    if(match(buf, " OR* ",  REG)) return 1;
    if(match(buf, " SBC* ", REG)) return 1;
    if(match(buf, " SUB* ", REG)) return 1;

    return 0;
}

/* returns true if buf matches an op that sets the CCR */
static int sets_flag(char *buf, char REG) {
    char tmp[MAX_TEMPORARY_STORAGE];

    if(alu_op(buf, tmp)         && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " ASL*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " ASR*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " COM*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " DEC*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " INC*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " LSL*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " LSR*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " ROL*", tmp) && _toUpper(*tmp)==REG) return 1;
    if(match(buf, " ROR*", tmp) && _toUpper(*tmp)==REG) return 1;

    return 0;
}

/* returns true if buf matches a conditionnal jump */
static int is_Bcc(char * buf) {
    /* short jumps */
    if(match(buf, " BGT ")) return 1;
    if(match(buf, " BLE ")) return 1;
    if(match(buf, " BGE ")) return 1;
    if(match(buf, " BLT ")) return 1;
    if(match(buf, " BEQ ")) return 1;
    if(match(buf, " BNE ")) return 1;
    if(match(buf, " BHI ")) return 1;
    if(match(buf, " BLS ")) return 1;
    if(match(buf, " BHS ")) return 1;
    if(match(buf, " BLO ")) return 1;
    if(match(buf, " BMI ")) return 1;
    if(match(buf, " BPL ")) return 1;
    
    /* long jumps */
    if(match(buf, " LBGT ")) return 1;
    if(match(buf, " LBLE ")) return 1;
    if(match(buf, " LBGE ")) return 1;
    if(match(buf, " LBLT ")) return 1;
    if(match(buf, " LBEQ ")) return 1;
    if(match(buf, " LBNE ")) return 1;
    if(match(buf, " LBHI ")) return 1;
    if(match(buf, " LBLS ")) return 1;
    if(match(buf, " LBHS ")) return 1;
    if(match(buf, " LBLO ")) return 1;
    if(match(buf, " LBMI ")) return 1;
    if(match(buf, " LBPL ")) return 1;

    return 0;
}

/* number of lines changed */
static int change;

/* replaces the buffer with an optimized code */
/* original buffer is kept as comment */
static void optim(char *buffer, char *rule, char *repl, ...) {
    char tmp[MAX_TEMPORARY_STORAGE], *s=tmp, *t = buffer;

    *s = '\0';

    /* insert replacement if provided */
    if(repl) {
        va_list ap;
        va_start(ap, repl);
        vsprintf(s, repl, ap);
        va_end(ap);
        while(*s) ++s;
        *s++ = '\n';
        *s   = '\0';
    }
    
    /* add our own comment if any */
    if(rule) {
        char *t = "; peephole: ";
        while((*s = *t)) {++s;++t;}
        t = rule;
        while((*s = *t)) {++s;++t;}
        *s++ = '\n';
        *s   = '\0';
    }

    /* comment out line */
    *s++ = ';';
    while((*s = *t)) {++s;++t;}

    /* write result back into input buffer */
    strcpy(buffer, tmp);

    /* one more change */
    ++change;
}

/* returns true if the buffer matches a zero value */
static int isZero(char *_buf) {
    char *s = _buf;
    
    if(s == NULL) return 0;

    if(*s == '$') ++s;
    while(*s == '0') ++s;

    return _eq(' ', *s);
}

/* perform basic peephole optimization with a length-4 look-ahead */
static void basic_peephole(char buffer[LOOK_AHEAD][MAX_TEMPORARY_STORAGE], int zA, int zB) {
    /* allows presumably safe operations */
    int unsafe = ALLOW_UNSAFE;

    /* various local buffers */
    char variable1[MAX_TEMPORARY_STORAGE];
    char variable2[MAX_TEMPORARY_STORAGE];
    char variable3[MAX_TEMPORARY_STORAGE];
    char variable4[MAX_TEMPORARY_STORAGE];

    if ( match( buffer[0], " ST* *", variable1, variable2 )
    &&   match( buffer[1], " LD* *", variable3, variable4 )
    &&   strcmp(variable1, variable3)==0
    &&   strcmp(variable2, variable4)==0) {
        if(0 && unsafe && match(variable2, "_Ttmp") && !match(buffer[2], "*SR ") && !(*variable1=='D' && match(buffer[2], " IF "))) {
            char *fmt = NULL;
            /* in case flags are necessary (IF,LBcc), insert TST or LEAX */
            if(match(buffer[2], " IF ") && match(buffer[3], " LB"))
                fmt = *variable1=='X' ? "\tLEAX ,X" : "\tTST%c";
            optim( buffer[0], "(unsafe, presumed dead)", fmt, _toUpper(*variable1));
        }

        if(unsafe && match(buffer[2], " * [", NULL))
            optim( buffer[0], "(unsafe, presumed dead)", NULL);
        optim( buffer[1], "rule #1 (STORE*,LOAD*)", NULL);
    }

    if ( match( buffer[0], " CLR *", variable1 )
    &&   match( buffer[2], " ST* *", variable2, variable3 )
    &&   strchr("AB", _toUpper(*variable2))
    &&   strcmp(variable1, variable3)==0) {
        optim( buffer[0], "rule #2 (CLEAR*,LOAD*)", NULL);
    }

    if ( isZero(match(buffer[0], " LD* #*", variable1, variable2) )
    &&   strchr("AB", _toUpper(*variable1)) ) {
        optim(buffer[0],"rule #3 (LOAD#0)", "\tCLR%c", _toUpper(*variable1));
    }

    if ( match(buffer[0], " EOR* #$ff", variable1)
    &&   strchr("AB", _toUpper(*variable1)) ) {
        optim(buffer[0], "rule #4 (EOR #$FF)", "\tCOM%c", _toUpper(*variable1));
    }

    if ( (match(buffer[0], " LD* ", variable1) || match(buffer[0], " CLR*", variable1))
    &&   match(buffer[1], " LD* ", variable2)
    &&   *variable1 == *variable2) {
        optim(buffer[0], "rule #5 (LOAD/CLR,LOAD)", NULL);
    }

    if ( match( buffer[0], " LD")
    &&   match( buffer[1], " ST")
    && _strcmp( buffer[2], buffer[0] )==0
    && unsafe) {
        optim( buffer[2], "rule #6 (LOAD*,STORE,LOAD*)", NULL);
    }

    if ( match(buffer[0], " ST* *", NULL, variable1)
    &&   match(buffer[1], " LD* *", NULL, variable2)
    && _strcmp(variable1, variable2)!=0
       && _strcmp(buffer[0],buffer[2])==0 ) {
        optim(buffer[0], "rule #7 (STORE*->LOAD->STORE*)", NULL);
    }

    if ( match(buffer[0], " ST")
    && _strcmp(buffer[0], buffer[1])==0) {
        optim(buffer[0], "rule #8 (STORE*,STORE*)", NULL);
    }
    if ((match(buffer[0], " ST* *+", NULL, variable1) || match(buffer[0], " ST* *", NULL, variable1))
    &&   match(buffer[1], " * *", NULL, variable2) &&  strcmp(variable1, variable2) !=0
    && _strcmp(buffer[2], buffer[0])==0) {
        optim(buffer[0], "rule #8 (STORE*,?,STORE*)", NULL);
    }
    if ((match(buffer[0], " ST* *+", NULL, variable1) || match(buffer[0], " ST* *", NULL, variable1))
    &&   match(buffer[1], " * *", NULL, variable2) &&  strcmp(variable1, variable2) !=0
    &&   match(buffer[2], " * *", NULL, variable2) &&  strcmp(variable1, variable2) !=0
    && _strcmp(buffer[3], buffer[0])==0) {
        optim(buffer[0], "rule #8 (STORE*,?,?,STORE*)", NULL);
    }

    if( (match(buffer[0], " LD* ", variable1) || match(buffer[0], " ST* ",variable1))
    &&  isZero(match(buffer[1], " CMP* #*", variable2, variable3))
    &&  *variable1==*variable2) {
        optim(buffer[1], "rule #9 (LOAD/STORE,CMP #0)", NULL);
    }
    
    if ( match(buffer[0], " LDD *", variable1)
    &&   match(buffer[1], " STD _Ttmp*", variable2)
    &&   match(buffer[2], " LDX *", variable3)
    &&   match(buffer[3], " CMPX _Ttmp*", variable4)
    &&  _strcmp(variable2, variable4)==0) {
        if(unsafe) {
            optim(buffer[0], "rule #10 (LDD,STD*,LDX,CMPX*)",
                variable1[0]=='#' && variable1[1]=='$' && variable1[2]=='0' && variable1[3]=='0'
                ? "\tCLRA" : NULL);
            optim(buffer[1], "(unsafe, presumed dead)", NULL);
            optim(buffer[3], NULL, "\tCMPX %s", variable1);
        } else {
            optim(buffer[3], "rule #10 (LDD,STD*,LDX,CMPX*)", "\tCMPX %s", variable1);
        }
    }
    
    if ( match(buffer[0], " LDD *", variable1)
    &&   match(buffer[1], " STD _Ttmp*", variable2)
    &&   match(buffer[2], " LDD *", variable3)
    &&   match(buffer[3], " ADD _Ttmp*", variable4)
    &&  _strcmp(variable2, variable4)==0) {
        if(unsafe) {
            optim(buffer[0], "rule #11 (LDD,STD*,LDD,ADDD*)", NULL);
            optim(buffer[1], "(unsafe, presumed dead)", NULL);
            optim(buffer[3], NULL, "\tADDD %s", variable1);
        } else {
            optim(buffer[3], "rule #11 (LDD,STD*,LDD,ADDD*)", "\tADDD %s", variable1);
        }
    }

    if ( match(buffer[0], " STD *", variable1)
    &&   match(buffer[1], " LDX *", variable2)
    &&   _strcmp(variable1,variable2)==0) {
        if(unsafe) optim(buffer[0], "(unsafe, presumed dead)", NULL);
        optim(buffer[1], "rule #12 (STD*,LDX*)", "\tTFR D,X");
    }

    if ( match(buffer[0], " STD *", variable1)
    &&   match(buffer[1], " LDA *+1", variable2)
    &&   strcmp(variable1, variable2)==0) {
        if(unsafe) optim(buffer[0], "(unsafe, presumed dead)", NULL);
        optim(buffer[1], "rule #13 (STD,LDA+1)", "\tTFR B,A");
    }

    if ( match(buffer[0], " LDD #*", variable1)
    &&   match(buffer[1], " ADDD #*", variable2)) {
        optim(buffer[0], "rule #14 (LDD#,ADD#)", "\tLDD #%s+%s", variable1, variable2);
        optim(buffer[1], NULL, NULL);
    }

    if ( match(buffer[0], " STX *", variable1)
    &&   match(buffer[1], " CLRA")
    &&   match(buffer[2], " LDX *", variable2)
    &&   _strcmp(variable1,variable2)==0) {
        optim(buffer[0], "rule #15 (STX*,CLRA,LDX*)", NULL);
        optim(buffer[2], NULL, "\tSTX %s", variable1);
    }

    if ( match(buffer[0], " STD *", variable1)
    &&   match(buffer[1], " LDD *", variable2)
    &&   match(buffer[2], " ADDD *", variable3)
    &&   strcmp(variable1,variable3)==0) {
        if(unsafe) optim(buffer[0], "(unsafe, presumed dead)", NULL);
        optim(buffer[1], "rule #16 (STD*,LDD,ADD*)", NULL);
        optim(buffer[2], NULL, "\tADDD %s", variable2);
    }

    if ( match(buffer[0], " STA *", variable1)
    &&   match(buffer[1], " LDA *", variable2)
    &&   match(buffer[2], " *A *", variable3, variable4)
    &&   strcmp(variable1,variable4)==0
    &&   (match(variable3, "OR") || match(variable3,"AND") || match(variable3,"EOR") || match(variable3,"ADD"))
    ) {
        if(unsafe) optim(buffer[0], "(unsafe, presumed dead)", NULL);
        optim(buffer[1], "rule #17 (STA*,LDA,ORA/ANDA/EORA/ADDA*)", NULL);
        optim(buffer[2], NULL, "\t%sA %s", variable3, variable2);
    }


    if ( match(buffer[0], " STD _Ttmp*", variable1)
    &&   match(buffer[1], " LD* [_Ttmp*]", variable2, variable3)
    &&   strcmp(variable1,variable3)==0) {
        if(unsafe) optim(buffer[0], "(unsafe, presumed dead)", NULL);
        optim(buffer[1], "rule #18 (STD,LDD[])", "\tTFR D,X\n\tLD%c ,X", _toUpper(*variable2));
    }

    if ( match(buffer[0], " STD _Ttmp*", variable1)
    &&   match(buffer[1], " LD* ", variable2)
    &&   match(buffer[2], " ST* [_Ttmp*]", variable3, variable4)
    &&   *variable2==*variable3
    &&   strcmp(variable1,variable4)==0
    &&   unsafe) {
        optim(buffer[0], "(unsafe, presumed dead)", "\tTFR D,X");
        optim(buffer[2], "rule #19 (STD,LOAD,STORE[])", "\tST%c ,X", *variable2);
    }

    if ( match(buffer[1], " TST*", variable1)
    &&  sets_flag(buffer[0], *variable1)) {
        optim(buffer[1], "rule #20 (FLAG-SET,TST)", NULL);
    }

    if ( match(buffer[0], " LDB #$01")
    &&   match(buffer[1], " LDX *", variable1)
    &&   match(buffer[2], " JSR CPUMATHMUL16BITTO32*", NULL)) {
        optim(buffer[0], "rule #21 (MUL#1)", "\tLDD %s", variable1);
        optim(buffer[1], NULL, "\tLDX #0");
        optim(buffer[2], NULL, NULL);
    }

    if ( match(buffer[0], " STB *", variable1)
    &&   match(buffer[1], " STA ")
    &&   match(buffer[2], " LDA *", variable2)
    &&   match(buffer[3], " STA *", variable3)
    &&   strcmp(variable1, variable2)==0) {
        optim(buffer[2], "rule #22 (STB*,STA,LDA*,STA)", NULL);
        optim(buffer[3], NULL, "\tSTB %s", variable3);
    }
    
    if(zA && zB
    &&   match(buffer[1], " STD _Ttmp*", variable2)
    &&   match(buffer[2], " LDX *", variable3)
    &&   match(buffer[3], " CMPX _Ttmp*", variable4)
    &&  _strcmp(variable2, variable4)==0) {
        if(unsafe) optim(buffer[0], "(unsafe, presumed dead)", NULL);
        optim(buffer[3], "rule #23 (D=0,STD*,LDX,CMPX*)", NULL);
    }
    
    if( match(buffer[0], " STD _Ttmp*", variable1)
    &&  match(buffer[1], " LDD _Ttmp*", variable2)
    &&  match(buffer[2], " LDX _Ttmp*", variable3)
    &&  strcmp(variable1,variable3)==0
    && !match(buffer[4], " IF ")
    &&  unsafe) {
        optim(buffer[0], "rule #24 (STD*,LDD,CMPX*)", "\tTFR D,X");
        optim(buffer[2], NULL, NULL);
    }

}

/* check if buffer matches any of xxyy (used for LDD #$xxyy op) */
static char *chkLDD(char *buffer, char *xxyy, char *buf) {
    return match( buffer, " LDD #$*", buf) &&
        strlen(buf)>=4 &&
        (xxyy[0]=='-' || xxyy[0]==buf[0]) &&
        (xxyy[1]=='-' || xxyy[1]==buf[1]) &&
        (xxyy[2]=='-' || xxyy[2]==buf[2]) &&
        (xxyy[3]=='-' || xxyy[3]==buf[3]) ? buf : NULL;
}

/* can this opcode make A non zero */
static int can_nzA(char *buf) {
    char *s;

    for(s = buf; !_eol(*s) && *s!=','; ++s);

    if(!match(buf, " ")) return 1;
    if(match(buf, " ADDA ")) return 1;
    if(match(buf, " ADDD ")) return 1;
    if(match(buf, " BSR ")) return 1;
    if(match(buf, " COMA")) return 1;
    if(match(buf, " DECA")) return 1;
    if(match(buf, " EORA ")) return 1;
    if(match(buf, " EXG ")) return 1;
    if(match(buf, " INCA")) return 1;
    if(match(buf, " JSR ")) return 1;
    if(match(buf, " LDA ")) return 1;
    if(match(buf, " LDD ")) return 1;
    if(match(buf, " ORA ")) return 1;
    if(match(buf, " PULS ")) return 1;
    if(match(buf, " PULU ")) return 1;
    if(match(buf, " ROLA ")) return 1;
    if(match(buf, " RORA ")) return 1;
    if(match(buf, " RTI")) return 1;
    if(match(buf, " RTS")) return 1;
    if(match(buf, " SBCA ")) return 1;
    if(match(buf, " SEX")) return 1;
    if(match(buf, " SUBA ")) return 1;
    if(match(buf, " SUBD ")) return 1;
    if(match(buf, " TFR ") && s[0]==',' && s[1]=='A') return 1;

    return 0;
}

/* can this opcode make B non zero */
static int can_nzB(char *buf) {
    char *s;

    for(s = buf; !_eol(*s) && *s!=','; ++s);

    if(!match(buf, " ")) return 1;
    if(match(buf, " ADDB ")) return 1;
    if(match(buf, " ADDD ")) return 1;
    if(match(buf, " BSR ")) return 1;
    if(match(buf, " COMB")) return 1;
    if(match(buf, " DECB")) return 1;
    if(match(buf, " EORB ")) return 1;
    if(match(buf, " EXG ")) return 1;
    if(match(buf, " INCB")) return 1;
    if(match(buf, " JSR ")) return 1;
    if(match(buf, " LDB ")) return 1;
    if(match(buf, " LDD ")) return 1;
    if(match(buf, " ORB ")) return 1;
    if(match(buf, " PULS ")) return 1;
    if(match(buf, " PULU ")) return 1;
    if(match(buf, " ROLB")) return 1;
    if(match(buf, " RORB")) return 1;
    if(match(buf, " RTI")) return 1;
    if(match(buf, " RTS")) return 1;
    if(match(buf, " SBCB ")) return 1;
    if(match(buf, " SUBB ")) return 1;
    if(match(buf, " SUBD ")) return 1;
    if(match(buf, " TFR ") && s[0]==',' && s[1]=='B') return 1;

    return 0;
}

/* optimisations related to A or B being zero */
static void optim_zAB(char line[MAX_TEMPORARY_STORAGE], int *zA, int *zB) {
    char tmp[MAX_TEMPORARY_STORAGE];
    int unsafe = ALLOW_UNSAFE;
    
    if(*zA) {
        if (match( line, " CLRA")) {
            optim( line, "rule #1001 (A=0)", NULL);
        } else if (match( line, " LDA #$ff")) {
            optim( line, "rule #1002 (A=0)", "\tDECA");
            *zA = 0;
        } else if (match(line, " LDA #$01")) {
            optim( line, "rule #1003 (A=0)", "\tINCA");
            *zA = 0;
        } else if ( chkLDD( line, "00--", tmp)) {
            optim(line, "rule #1004 (A=0)", "\tLDB #$%c%c", tmp[2], tmp[3]);
            *zB = 0;
        } else if(can_nzA(line)) {
            *zA = 0;
        }
    } else if ( chkLDD(line, "00--", tmp) || match( line, " LDD #0") || match( line, " CLRA") ) {
        *zA = 1;
    }

    if(*zB) {
        if (match( line, " CLRB")) {
            optim( line, "rule #1005 (B=0)", NULL);
        } else if (match( line, " LDB #$ff")) {
            optim( line, "rule #1006 (B=0)", "\tDECB");
            *zB = 0;
        } else if (match( line, " LDB #$01")) {
            optim( line, "rule #1007 (B=0)", "\tINCB");
            *zB = 0;
        } else if ( chkLDD( line, "--00", tmp) ) {
            optim( line, "rule #1008 (B=0)", "\tLDA #$%c%c", tmp[0], tmp[1]);
            *zA = 0;
        } else if (match( line, " TFR B,A")) {
            optim( line, "rule #1009 (B=0)", "\tCLRA");
            *zA = 1;
        } else if(can_nzB(line)) {
            *zB = 0;
        }
    } else if ( chkLDD(line, "--00", tmp) || match( line, " LDD #0") || match( line, " CLRB") ) {
        *zB = 1;
    }
}

/* optimizations related to variables */

/* variables database */
static struct {
    struct var {
        char *name;
        int size;
        int nb_rd;
        int nb_wr;
        int offset; /* 0=unchanged, >0 offset to page 0; -1 = candidate for inlining, -2 = inlined */
    } *tab;
    int capacity;
    int size;
    int page0_max;
} vars;

/* clears the database */
static void vars_clear(void) {
    int i;
    for(i=0; i<vars.size; ++i) free(vars.tab[i].name);
    vars.size = 0;
    vars.page0_max = 0;
}

/* gets (or creates) an entry for a variable from the data-base */
struct var *vars_get(char *name) {
    struct var *ret = NULL;
    int i;

    char *s=strchr(name,'+');
    if(s) *s='\0';

    for(i=0; i<vars.size ; ++i) {
        if(strcmp(vars.tab[i].name, name)==0) {
            ret = &vars.tab[i];
        }
    }
    if(ret == NULL) {
        if(vars.size == vars.capacity) {
            vars.capacity += 16;
            vars.tab = realloc(vars.tab, sizeof(*vars.tab)*vars.capacity);
        }
        ret = &vars.tab[vars.size++];
        ret->name   = strdup(name);
        ret->size   = 0;
        ret->nb_rd  = 0;
        ret->nb_wr  = 0;
        ret->offset = 0;
    }
    if(s) *s='+';

    return ret;
}

/* look for variable uses and collect data about he variables */
static void vars_scan(char buffer[LOOK_AHEAD][MAX_TEMPORARY_STORAGE]) {
    char buf[MAX_TEMPORARY_STORAGE];
    char val[MAX_TEMPORARY_STORAGE];

    if (match( buffer[0], " CLR _*", buf)
    || match( buffer[0], " ST* _*", val, buf) ) {
        struct var *v = vars_get(buf);
        v->nb_wr++;
    }
    if (match( buffer[0], " ADD* _*", NULL, buf)
    ||  match( buffer[0], " ADC* _*", NULL, buf)
    ||  match( buffer[0], " AND* _*", NULL, buf)
    ||  match( buffer[0], " CMP* _*", NULL, buf)
    ||  match( buffer[0], " EOR* _*", NULL, buf)
    ||  match( buffer[0], " LD* _*",  NULL, buf)
    ||  match( buffer[0], " SBC* _*", NULL, buf)
    ||  match( buffer[0], " SUB* _*", NULL, buf) ) {
        struct var *v = vars_get(buf);
        v->nb_rd++;
    }
    if( match( buffer[0], " ASL _*", buf)
    ||  match( buffer[0], " ASR _*", buf)
    ||  match( buffer[0], " COM _*", buf)
    ||  match( buffer[0], " DEC _*", buf)
    ||  match( buffer[0], " INC _*", buf)
    ||  match( buffer[0], " LSL _*", buf)
    ||  match( buffer[0], " LSR _*", buf)
    ||  match( buffer[0], " ROL _*", buf)
    ||  match( buffer[0], " ROR _*", buf)
    ||  match( buffer[0], " TST _*", buf) ) {
        struct var *v = vars_get(buf);
        v->nb_wr++;
        v->nb_rd++;
    }
    if(match(buffer[0], " * _*", buf, val) && alu_op(buffer[0], NULL) ) {
        struct var *v = vars_get(val);
        v->offset = -1;
    }

    if( match( buffer[0], "_* rzb *", buf, val)
    ||  match( buffer[0], "_* fcb *", buf, val)) {
        struct var *v = vars_get(buf);
        v->size = atoi(val);
    }

    if( match(buffer[0], "* equ $*", buf, val) && *buf!='_' && strlen(val)==2) {
        int v = strtol(val, NULL, 16);
        if (v > vars.page0_max) vars.page0_max = v+2;
    }
}

/* compares two variables according to their access-count */
static int vars_cmp(const void *_a, const void *_b) {
    const struct var *a = _a;
    const struct var *b = _b;

    int diff = ((a->nb_rd + a->nb_wr) - (b->nb_rd + b->nb_wr));

    return -(diff!=0 ? diff : strcmp(a->name, b->name)); // Ttmp < Tstr
}

/* decide which variable goes in direct-page, which will be inlined */
static int vars_dp(int *num_dp, int *num_inlined) {
    int i;

    *num_dp = *num_inlined = 0;

    qsort(vars.tab, vars.size, sizeof(*vars.tab), vars_cmp);

    for(i = 0; i<vars.size && vars.page0_max < 255; ++i) {
        struct var *v = &vars.tab[i];

        if(v->offset == -1 && v->size>2) v->offset = 0; /* can't inline > 2 bytes */

        // printf("%s %d %d %d %d\n", v->name, v->nb_rd+v->nb_wr, v->offset, v->size, vars.page0_max);
        if(v->nb_rd>0
        && vars.page0_max + v->size <= 256
        && (v->offset == 0 && v->size<=4
        ||  v->offset ==-1)
        //&& (match(v->name,"PEN") ||match(v->name,"PAPER") || match(v->name,"Ttmp") || (v->name[0]>='a'))
        // && !match(v->name, "Tstr")
        ) {
            if(v->offset == -1) {
                /* check if inlining is good */
                /* LDA: imm=2, dp=4, extended=5
                   LDD: imm=3, dp=5, extended=6 */
                int dp_cost     = (3+v->size)*(v->nb_rd + v->nb_wr);
                int inline_cost = (4+v->size)*(v->nb_rd + v->nb_wr - 1)+(1+v->size);
                if( dp_cost < inline_cost ) {
                    v->offset = 0;
                } else {
                    ++*num_inlined;
                }
            }

            if(v->offset == 0) {
                v->offset = vars.page0_max;
                vars.page0_max += v->size;
                ++*num_dp;
            }
        }
    }
}

/* performs optimizations related to variables */
static void vars_optim(char buffer[LOOK_AHEAD][MAX_TEMPORARY_STORAGE]) {
    char buf[MAX_TEMPORARY_STORAGE];
    char op[MAX_TEMPORARY_STORAGE];

    if(match( buffer[0], "_* rzb ", buf) ) {
        struct var *v = vars_get(buf);
        if(v->nb_rd==0 && v->size<=4) {
            optim(buffer[0], "unread variable",NULL);
        } else if(v->offset > 0) {
            optim(buffer[0], "moved to diect-page", "_%s equ $%02X", buf, v->offset);
        } else if(v->offset < 0) {
            optim(buffer[0], "inlined", NULL);
        }
    }

    if(match( buffer[0], " ST* _*", op, buf) ) {
        struct var *v = vars_get(buf);
        if(v->nb_rd == 0) {
            char *rep = NULL;
            if(match(buffer[1], " IF ") && match(buffer[2], " LB")) {
                if(*op=='X') rep = "\tLEAX ,X";
                else sprintf(rep = op, "\tTST%c", *op);
            }
            optim(buffer[0], "unread variable",rep);
        }
    }

    if(match( buffer[0], " * _*", op, buf) ) {
        struct var *v = vars_get(buf);

        if(v->offset > 0) {
            optim(buffer[0], "moved to diect-page", "\t%s <_%s", op, buf);
        } else if(v->offset == -1 && alu_op(buffer[0], NULL)) {
            v->offset = -2;
            optim(buffer[0], "inlined", "\t%s #-1\n_%s equ *-%d", op, buf, v->size);
        }
    }
    if(match( buffer[0], " * [_*]", op, buf) ) {
        struct var *v = vars_get(buf);
        if(v->offset > 0) {
            optim(buffer[0], "moved to diect-page", "\t%s [$%04x+_%s]", op, DIRECT_PAGE, buf);
        }
    }
    if(match( buffer[0], " * #_*", op, buf) ) {
        struct var *v = vars_get(buf);
        if(v->offset > 0) {
            optim(buffer[0], "moved to diect-page", "\t%s #$%04x+_%s", op, DIRECT_PAGE, buf);
        }
    }
}

/* collapse all heading spaces into a single tabulation */
static void out(FILE *f, char *_buf) {
	char *s = _buf;
	int tab = 0;
	while(*s==' ' || *s=='\t') {tab = 1; ++s;}
	if(tab) fputs("\t", f);
	fputs(s, f);
}

/* main entry-point for this service */
void target_peephole_optimizer( Environment * _environment ) {
    const int keep_comments = KEEP_COMMENTS;
    char fileNameOptimized[MAX_TEMPORARY_STORAGE];

    sprintf( fileNameOptimized, "%s.asm", tmpnam(NULL) );

    char buffer[LOOK_AHEAD][MAX_TEMPORARY_STORAGE];
    int pass = 0;
    int vars_pass = 0;

    for(change=1; change;) {
        FILE * fileAsm = fopen( _environment->asmFileName, "rt" );
        FILE * fileOptimized = fopen( fileNameOptimized, "wt" );

        int line = 0;
        int zA = 0, zB = 0;
        int i;

        /* clears our look-ahead buffers */
        for(i = LOOK_AHEAD; i--;) *buffer[i] = '\0';

        ++pass; change = 0;

        /* reset database if it isn't time for variable optimizations */
        if(vars_pass == 0) vars_clear();

        while( !feof( fileAsm ) ) {
            /* print out oldest buffer */
            if ( line >= LOOK_AHEAD ) out(fileOptimized, buffer[0]);
            /* shift the buffers */
            for(i=0; i<LOOK_AHEAD-1; ++i) strcpy(buffer[i], buffer[i+1]);
            /* read next line, merging adjacent comments */
            do {
                /* read next line */
                fgets( buffer[LOOK_AHEAD-1], MAX_TEMPORARY_STORAGE, fileAsm );
                /* merge comment with previous line if we do not overflow the buffer */
                if(isAComment(buffer[LOOK_AHEAD-1])
                && strlen(buffer[LOOK_AHEAD-2]) + strlen(buffer[LOOK_AHEAD-1]) + 1 <= MAX_TEMPORARY_STORAGE) {
                    if(keep_comments) strcat(buffer[LOOK_AHEAD-2], buffer[LOOK_AHEAD-1]);
                    buffer[LOOK_AHEAD-1][0] = '\0';
                } else break;
            } while(!feof( fileAsm ) );
            /* peephole phase */
            if(vars_pass == 0) {
                // simple
                basic_peephole(buffer, zA, zB);
                // complex
                optim_zAB(buffer[0], &zA, &zB);
                // even more complex
                if(change == 0) vars_scan(buffer);
            /* variable-optimization phase */
            } else {
                vars_optim(buffer);
            }

            ++line;
        }

        for(i=0; i<LOOK_AHEAD; ++i) out( fileOptimized, buffer[i]);

        /* log info at the end of the file */
        fprintf(fileOptimized, "; peephole: pass %d, %d change%s.\n", pass, change, change>1 ?"s":"");

        /* variable optimization phase ? */
        if(change == 0) {
            if(vars_pass == 0) {
                int num_dp, num_inline;
                /* yes ==> off we go! */
                vars_pass = 1;
                vars_dp(&num_dp, &num_inline);
                /* log info at the end of the file */
                fprintf(fileOptimized, "; peephole+: %d variable%s moved to direct-page, %d inlined.\n",
                    num_dp, num_dp>1 ?"s":"", num_inline);
                /* redo peephole if the variable optimization gives any changes to optimize even more */
                change = 1;
            }
        }

        fclose( fileAsm );
        fclose( fileOptimized );

        /* makes our generated file the new asm file */
        rename( fileNameOptimized, _environment->asmFileName );
    }
}

